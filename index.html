<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    :root{
        --cell-size: 20px;
    }
    *{
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body{
        display: flex;
        align-items: center;
        justify-content: space-around;
    }
    button{
        position: relative;
        overflow: hidden;
        border: none;
        background-color: tomato;
        outline: none;
        margin: 5px;
        padding: 10px;
        border-radius: 2px;
        color: white;
        font-weight: bold;
        box-shadow: 0 1px 6px 0px rgb(32 33 36 / 38%);
        transition: transform 0.4s;
    }
    button::after{
        content:'';
        position: absolute;
        width: 20px;
        height: 100px;
        left: 20%;
        top: -50%;
        transform: rotate(-30deg);
        filter:blur(5px);
        background-color: rgba(255, 255, 255, 0.3);
        transition: left 0.5s;
    }
    button:hover{
        transform: perspective(400px) rotateY(20deg);
    }
    button:hover:after{
        left: 25%;
    }
    #game-board{
        position: relative;
        width: 500px;
        height: 500px;
        /* border: 1px inset black; */
        box-shadow: 0 1px 6px 0px rgb(32 33 36 / 38%);
        border-radius: 5px;
        overflow: hidden;
    }
    #score-board{
        height: 200px;
        width: 200px;
        box-shadow: 0 1px 6px 0px rgb(32 33 36 / 38%);
        text-align: center;
        vertical-align: center;
        font-weight: bold;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        font-size: 100px;
        padding-top: 25px;
        border-radius: 5px;
        color: rgb(68, 68, 68);
    }
    #buttons-board{
        display: flex;
        flex-direction: column;
        width: 200px;
    }
    #food{
        position: absolute;
        /* default params */
        height: var(--cell-size);
        width: var(--cell-size);
        background-color: red;

        /* temporary */
        right: 0;
    }
    #snake > div{
        position: absolute;
        height: var(--cell-size);
        width: var(--cell-size);
        background-color: limegreen;
        
        /* transition: all 0.4s; */
    }   
    .cells-animated{
        transition: all 0.4s;
    }
</style>
<body>
        <div id="buttons-board">
            <button onclick="animateSnake()">toggle animation</button>
            <button onclick="foodSpawnCheck()">check food spawn</button>
        </div>
        <div id="game-board">
            <div id="snake">
                
            </div>

        </div>
        <div id="score-board">

        </div>
</body>
<script>
    class Config{
        constructor(){
            //================================== configurable values
            this.boardSize;
            this.cellSize; 
            this.speed ;
            // snakeColor

            //================================== static values
            this.snakeDiv = document.getElementById('snake');
            this.scoreDiv = document.getElementById('score-board');
            this.foodPos;
            this.foodDiv;
        }
    }
    class Snake extends Config{
        constructor(boardSize,cellSize,speed){
            super(); //$$
            //================================== updating config values;
            this.boardSize = boardSize;
            this.cellSize = cellSize;
            this.speed = speed;

            this.snakeDirection = 'right';
            this.snakeTailDiv; //this field is variable
            this.snakeHeadDiv; //this field is static => always points to same div
            this.snakeNeckDivPos; //position of nth child div in #snake
            this.snakeTailDivPos; //position of nth child div on #snake

            this.snakeLength = 3; //can not be set less, 3 is minimum //or it can be less :D
            this.snakeTrail = [];
            this.snakeAnimated = 0;
        }

        snakeExpand(){
            //add new coordinate to array
            this.snakeTrail.unshift(this.snakeTrail[0]);

            // and new div to CORRECT POSITION! to represent new cell
            let snakeCell = document.createElement('div');
            if(game.snakeAnimated){
                snakeCell.className = "cells-animated";
            }
            this.snakeDiv.insertBefore(snakeCell, this.snakeDiv.children[this.snakeTailDivPos]);

            snakeCell.style.left = this.snakeTrail[0].cellX;
            snakeCell.style.top = this.snakeTrail[0].cellY;

            this.snakeLength++;
            // this.snakeTailDivPos = 1;
        }
        snakeTrim(){
            //just trim the part of the snake on self hit would be more fun
        }
        restartGame(){
            this.snakeDiv.innerHTML = '';
            this.foodDiv.remove();

            this.snakeLength = 3; //can not be set less, 3 is minimum //or it can be less :D
            this.snakeTrail = [];
            this.foodDiv = undefined;
            
            this.spawn('food');
            this.spawn('snake');
        }

        moveSnake(direction){
            let newPos;

            //calculate new position
            switch(direction){
                case 'left':
                    newPos = { 
                        "cellX": this.snakeTrail[this.snakeTrail.length-1].cellX - this.cellSize,
                        "cellY": this.snakeTrail[this.snakeTrail.length-1].cellY 
                    }
                break;
                case 'right':
                    newPos = { 
                        "cellX": this.snakeTrail[this.snakeTrail.length-1].cellX + this.cellSize,
                        "cellY": this.snakeTrail[this.snakeTrail.length-1].cellY 
                    }
                break;
                case 'top':
                    newPos = { 
                        "cellX": this.snakeTrail[this.snakeTrail.length-1].cellX,
                        "cellY": this.snakeTrail[this.snakeTrail.length-1].cellY - this.cellSize 
                    }
                break;
                case 'down':
                    newPos = { 
                        "cellX": this.snakeTrail[this.snakeTrail.length-1].cellX,
                        "cellY": this.snakeTrail[this.snakeTrail.length-1].cellY + this.cellSize
                    }
                break;
            }

            //checks all snake cells if newPos matches snake tail cell
            for(let i = 0; i < this.snakeTrail.length-3; i++){
                if( this.snakeTrail[i].cellX === newPos.cellX & this.snakeTrail[i].cellY === newPos.cellY ){
                    this.restartGame();
                    return;
                    //pause game
                    //or eat tail and coninue playing, sounds more fun
                }
            }
            //checks if snake hit the foodCell
            if(this.foodPos.cellX === newPos.cellX & this.foodPos.cellY === newPos.cellY){
                this.spawn('food');
                this.snakeExpand();                
                //Points++ //or we already track snake length
                this.scoreDiv.innerText = this.snakeLength-3
            }
            //check if newPos goes out of boundary
            if(newPos.cellX >= this.boardSize){
                newPos.cellX -= this.boardSize;
            }
            if(newPos.cellX < 0){
                newPos.cellX = 500 + newPos.cellX; //"+" because cellX is now negative number;
            }
            if(newPos.cellY >= this.boardSize){
                newPos.cellY -= this.boardSize;
            }
            if(newPos.cellY < 0){
                newPos.cellY = 500 + newPos.cellY; //"+" because cellY is now negative number;
            }

            //Moving snake //Method:4
            //Last cellDiv to current headDivPosition and current headDiv to newPosition

                //get access to tailDiv
            this.snakeTailDiv = this.snakeDiv.children[this.snakeTailDivPos]; 
                //move tailDiv to Head position => it will become neck
            this.snakeTailDiv.style.left = this.snakeHeadDiv.style.left;
            this.snakeTailDiv.style.top = this.snakeHeadDiv.style.top;
                //move headDiv to newPos
            this.snakeHeadDiv.style.left = newPos.cellX;
            this.snakeHeadDiv.style.top = newPos.cellY;
                //update headPos and tailPos tracking => here tail becomes neck
            this.snakeNeckDivPos = this.snakeTailDivPos;
            if(this.snakeTailDivPos === this.snakeLength-2){ //-2 because we dont track head, -1 is the head position in array
                this.snakeTailDivPos = 0;
            }else{
                this.snakeTailDivPos++;
            }; 

            //updating coordinates array
            this.snakeTrail.push(newPos)
            this.snakeTrail.shift()

            // console.log(`newPos: x:${newPos.cellX} y:${newPos.cellY}`)
            // console.log(`foodPos: x:${this.foodPos.cellX} y:${this.foodPos.cellY}`)
        }
        
        spawn(element){

            //generate random coords so food is inside the board and not on snake position
            //because of floor 500 will never be reached so foodX will be max 490
            let randX = Math.floor(Math.random()*this.boardSize); 
            let elementX = randX - randX%this.cellSize;

            let randY = Math.floor(Math.random()*this.boardSize);
            let elementY = randY - randY%this.cellSize;

            switch(element){
                case 'snake':
                    for(let i = 0; i < this.snakeLength; i++){
                        // console.log(`pushing obj: ${elementX} ${elementY}`);
                        //filling snakeTrail with default snake length cells
                        this.snakeTrail.push(
                            { 
                                "cellX": elementX,
                                "cellY": elementY
                            }
                        )
                        //creating snake divCell
                        let snakeCell = document.createElement('div');
                        this.snakeDiv.appendChild(snakeCell);

                        //draw it
                        snakeCell.style.left = elementX;
                        snakeCell.style.top = elementY;
                    }

                    //save which child div is TailCell and which child div is NeckCell 
                    //positions match array numbering
                    this.snakeTailDivPos = 0;
                    this.snakeNeckDivPos = this.snakeLength-1;
                    this.snakeHeadDiv = this.snakeDiv.children[this.snakeLength-1]; // declare head

                    this.scoreDiv.innerText = this.snakeLength-3;
                break;
                case 'food':

                    //if foodPos matches any snakeTrail position re generate random position and try again
                    for(let i=0;i<this.snakeTrail.length;i++){
                        if(this.snakeTrail[i].cellX === elementX & this.snakeTrail[i].cellY === elementY){
                            this.spawn('food');
                            return;
                        }
                    }

                    //creating food divCell if it doenot exist
                    if(this.foodDiv === undefined){
                        let food = document.createElement('div');
                        food.id = 'food';
                        document.getElementById('game-board').appendChild(food);
                        this.foodDiv = food;
                    }

                    //updating foodPos value
                    this.foodPos = { 
                        "cellX": elementX,
                        "cellY": elementY
                    }
                    //drawing food divCell
                    this.foodDiv.style.left = elementX;
                    this.foodDiv.style.top = elementY;
                break;
            }
        }

        updateGame(){
            // main function that will update game at every tick

            this.moveSnake(this.snakeDirection);
        }
    }
    
    const game = new Snake(500,20,100);
    game.spawn('food');
    game.spawn('snake');

    // let head = document.querySelector(`#snake > div:nth-child(${game.snakeNeckDivPos})`)
    // let tail = document.querySelector(`#snake > div:nth-child(${game.snakeTailDivPos})`)

    setInterval(() => {
        game.updateGame();
    }, game.speed);


    // ============================================================ button test functions
    function animateSnake(){
        game.snakeAnimated = !game.snakeAnimated;
        [...document.querySelectorAll('#snake > div')].forEach((item)=>{
            item.classList.toggle('cells-animated');
        });
    }

    var interval
    function foodSpawnCheck(){
        if(interval === undefined){
            console.log('here');
            interval = setInterval(() => {
                game.spawn('food');
                foodSpawn = undefined;
            }, 50);
        }else{
            clearInterval(interval); 
            interval = undefined;
        }
        
    }
    

    // event listeners change game.snakeDirection based on keys pressed
    document.addEventListener('keydown', (event)=>{
        switch(event.key){
            case 'ArrowLeft':
                // game.moveSnake('left')
                if(game.snakeDirection != "right"){
                    game.snakeDirection = 'left';
                }
            break;
            case 'ArrowRight':
                // game.moveSnake('right')
                if(game.snakeDirection != "left"){
                    game.snakeDirection = 'right';
                }
            break;
            case 'ArrowUp':
                // game.moveSnake('top')
                if(game.snakeDirection != "down"){
                    game.snakeDirection = 'top';
                }
            break;
            case 'ArrowDown':
                // game.moveSnake('down')
                if(game.snakeDirection != "top"){
                    game.snakeDirection = 'down';
                }
            break;
        };
    })
    
    
</script>
</html>